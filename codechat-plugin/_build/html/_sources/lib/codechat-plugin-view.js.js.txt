'use babel';

// codechat-plugin-view.js
// =======================
//
// This file is responsible for the majority of the functionality, including:
// 1. Connecting a communicating with the server
// 2. Recording the actions of the user
// 3. Programming how the viewing dock operates
//
var net = require('net');
var path = require('path');


export default class CodechatPluginView {

  constructor(serializedState) {

    this.updateOnSave = false;
    this.client = new net.Socket();

    this.client.connect(50646, '192.168.0.104', function() {
       console.log('Connected');
       console.log('init');
       msg = {
         cmd: 'init',
         data: [atom.workspace.getActiveTextEditor().getPath(), atom.workspace.getActiveTextEditor().getText(), atom.project.relativizePath(atom.workspace.getActiveTextEditor().getPath())[0]],
         cursor: atom.workspace.getActiveTextEditor().getCursorBufferPosition()
       };

       // I'm using the `JSON <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON>`_


       this.client.write(JSON.stringify(msg));
       //this.client.write('{"cmd": "init", "data": ["' + atom.workspace.getActiveTextEditor().getPath().replace(/\\/g, "/") + '", "' + path.extname(atom.workspace.getActiveTextEditor().getPath()) + '", "content"]}' + '!@#$%^&*()' + atom.workspace.getActiveTextEditor().getText());

     }.bind(this));

    // Create root element
    this.element = document.createElement('div');
    this.element.classList.add('codechat-plugin');

    // Create message element
    const message = document.createElement('div');
    message.textContent = '';
    message.classList.add('message');
    this.element.appendChild(message);


	// Lost Connection Handler
    this.client.on('close', function() {
      message.textContent = 'Lost connection to the server!';
      this.client.destroy();
      this.onViewChange.dispose();
      this.onFileMod.dispose();
      this.onSave.dispose();
      this.onCursor.dispose();
    }.bind(this));

	// Recieving Data
     var completeData = '';
     var contentLength = 0;

     this.client.on('data', function(data) {
       console.log('recv');
       if (completeData == '') {
         contentLength = Number(data.slice(0, 10));
         console.log(contentLength.toString());
         completeData += data.toString().replace(data.slice(0, 10), "");
       } else {
         completeData += data;
       }

       if (completeData.length >= contentLength) {
         nextData = 'NULL'
         if (completeData.length > contentLength) {
           nextData = completeData.slice((contentLength), completeData.length + 1);
           console.log('concat');
           completeData = completeData.slice(0, contentLength);
         }

         console.log('complete msg');
         if (completeData.slice(0, 5) == 'ERROR') {
           atom.notifications.addError(completeData);
         } else if (completeData == 'T') {
           console.log(completeData);
           this.updateOnSave = true;
         } else if (completeData == 'F') {
           console.log(completeData);
           this.updateOnModif = false;
         } else {
           message.innerHTML = completeData;
         }
         if (nextData == 'NULL') {
           completeData = '';
         } else {
           contentLength = Number(nextData.slice(0, 10));
           console.log(contentLength.toString());
           completeData = nextData.toString().replace(nextData.slice(0, 10), "");
         }
         if (completeData.length == contentLength) {
           console.log('complete msg');
           if (completeData.slice(0, 5) == 'ERROR') {
             atom.notifications.addError(completeData);
           } else if (completeData == 'T') {
             this.updateOnSave = true;
           } else if (completeData == 'F') {
             this.updateOnSave = false;
           } else {
             message.innerHTML = completeData;
           }
           completeData = '';
         }

       }

      }.bind(this));


	// Text Editor Switching Handling
     this.currView = atom.workspace.getActiveTextEditor();

     this.onViewChange = atom.workspace.observeActiveTextEditor(editor => {
       if (editor != this.currView) {
         this.currView = editor;
         this.onFileMod.dispose();
         msg = {
           cmd: 'init',
           data: [atom.workspace.getActiveTextEditor().getPath(), atom.workspace.getActiveTextEditor().getText(), atom.project.relativizePath(atom.workspace.getActiveTextEditor().getPath())[0]],
           cursor: atom.workspace.getActiveTextEditor().getCursorBufferPosition()
         };

         this.client.write(JSON.stringify(msg));
       }


		// Text Editor Modification Handler
       this.onFileMod = atom.workspace.getActiveTextEditor().onDidStopChanging(event => {
         console.log('modif');

         console.log(this.updateOnSave);

         if (!this.updateOnSave) {
           msg = {
             cmd: 'init',
             data: [atom.workspace.getActiveTextEditor().getPath(), atom.workspace.getActiveTextEditor().getText(), atom.project.relativizePath(atom.workspace.getActiveTextEditor().getPath())[0]],
             cursor: atom.workspace.getActiveTextEditor().getCursorBufferPosition()
           };

           this.client.write(JSON.stringify(msg));
         }
         return;
        });
     });

     this.onSave = atom.workspace.getActiveTextEditor().onDidSave(event => {
       console.log('saved');
       msg = {
         cmd: 'init',
         data: [atom.workspace.getActiveTextEditor().getPath(), atom.workspace.getActiveTextEditor().getText(), atom.project.relativizePath(atom.workspace.getActiveTextEditor().getPath())[0]],
         cursor: atom.workspace.getActiveTextEditor().getCursorBufferPosition()
       };

       this.client.write(JSON.stringify(msg));
       return;
     });

     this.onCursor = atom.workspace.getActiveTextEditor().onDidChangeCursorPosition(event => {
       console.log('cursor changed');

       if (!this.updateOnSave) {
         msg = {
           cmd: 'init',
           data: [atom.workspace.getActiveTextEditor().getPath(), atom.workspace.getActiveTextEditor().getText(), atom.project.relativizePath(atom.workspace.getActiveTextEditor().getPath())[0]],
           cursor: atom.workspace.getActiveTextEditor().getCursorBufferPosition()
         };

         this.client.write(JSON.stringify(msg));
         return;
       }
     });


  }

  // Returns an object that can be retrieved when package is activated
  serialize() {
    return {
      // This is used to look up the deserializer function. It can be any string, but it needs to be
      // unique across all packages!
      deserializer: 'codechat-plugin/CodechatPluginView'
    };
  }

  // Tear down any state and detach
  destroy() {
    if (!this.client.destroyed) {
      this.onCursor.dispose();
      this.onSave.dispose();
      this.client.destroy();
      this.onViewChange.dispose();
      this.onFileMod.dispose();
    }

    console.log('destroyed');
    this.element.remove();

  }

  getElement() {
    return this.element;
  }

  getTitle() {
    // Used by Atom for tab text
    return 'CodeChat Preview';
  }

  getURI() {
    // Used by Atom to identify the view when toggling.
    return 'atom://codechat-plugin';
  }

  getDefaultLocation() {
    // This location will be used if the user hasn't overridden it by dragging the item elsewhere.
    // Valid values are "left", "right", "bottom", and "center" (the default).
    return 'right';
  }

  getAllowedLocations() {
    // The locations into which the item can be moved.
    return ['left', 'right', 'bottom'];
  }

}
